// ------------------------------------------------------------------------------
//  <auto-generated>
//     This code was generated from a template.
// 
//     Manual changes to this file will be overwritten if the code is regenerated.
//
//     Generated on 2017-11-20T14:28:30, by ESR Version 1.69.0.0 using ESR Database 
//  </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using System.Xml;
using System.Linq;
using System.Collections.Generic;
using DataContracts;
using System.Text.RegularExpressions;
using Ato.EN.IntegrationServices.CodeGenerationPAYEVNTEMP;

namespace Ato.EN.IntegrationServices.CodeGenerationPAYEVNT
{
    public partial class PAYEVNT2018ValidatorSubmit
    {
        /// <summary>
        /// The max parameter name length is restricted by the SBR1 and SBR2 schemas - the lowest common denominator of SBR 1 is used as the default
        /// </summary>
        private int _maxParameterNameLength;

        /// <summary>
        /// The max parameter value length is restricted by the SBR1 and SBR2 schemas
        /// </summary>
        private int _maxParameterValueLength;

        /// <summary>
        /// The SBR1 and ebms3 schemas do not allow parameter names or values to be the empty string
        /// </summary>
        private string _emptyParameterValue;

        /// <summary>
        /// Initializes a new instance of the <see cref="PAYEVNT2018ValidatorSubmit" /> class.
        /// </summary>
        /// <param name="maxParameterNameLength">Maximum length of the parameter name.</param>
        /// <param name="maxParameterValueLength">Maximum length of the parameter value.</param>
        /// <param name="emptyParameterValue">This value will be used in place of any parameter values that result in a null or empty value.</param>
        public PAYEVNT2018ValidatorSubmit(int maxParameterNameLength = 20, int maxParameterValueLength = 4096, string emptyParameterValue = "EMPTY")
        {
            _maxParameterNameLength = maxParameterNameLength;
            _maxParameterValueLength = maxParameterValueLength;
            _emptyParameterValue = emptyParameterValue;
        }

        #region Functions
        private static IEnumerable<string> Union(IEnumerable<string> list1, IEnumerable<string> list2)
        {
            IEnumerable<string> response;

            if (list1 == null && list2 == null)
            {
                response = null;
            }
            else if (list1 == null)
            {
                response = list2.Distinct();
            }
            else if (list2 == null)
            {
                response = list1.Distinct();
            }
            else
            {
                response = list1.Union(list2);
            }

            return response;
        }

        private static bool IsMatch(int? field, string expression, RegexOptions options = RegexOptions.None)
        {
            if (field == null)
                return false;
            else
                return Regex.IsMatch(Convert.ToString(field.Value), expression, options);
        }

        private static bool IsMatch(string field, string expression, RegexOptions options = RegexOptions.None)
        {
            if (field == null)
                return false;
            else
                return Regex.IsMatch(field, expression, options);
        }

        // This is just context and tuple counts where they are integer values - easier that changing the parsing logic to just return the value
        private static int Count(int count)
        {
            return count;
        }


        private static int Count<T>(IEnumerable<T> values)
        {
            return values == null ? 0 : values.Where(f => f != null).Count();
        }


        private static int Count<T>(ICollection<T> values)
        {
            return values == null ? 0 : values.Where(f => f != null).Count();
        }


        private static bool exists(bool value)
        {
            return value;
        }

        private static string GetValueOrEmpty(bool? val)
        {
            return (val.HasValue) ? val.ToString() : string.Empty;
        }

        private static string GetValueOrEmpty(DateTime? val)
        {
            return (val.HasValue) ? val.ToString() : string.Empty;
        }

        /// <summary>
        /// Get string value between [first] a and [last] b.
        /// </summary>
        public static string Between(string value, string a, string b)
        {
            int posA = value.IndexOf(a);
            int posB = value.LastIndexOf(b);
            if (posA == -1)
            {
                return "";
            }
            if (posB == -1)
            {
                return "";
            }
            int adjustedPosA = posA + a.Length;
            if (adjustedPosA >= posB)
            {
                return "";
            }
            return value.Substring(adjustedPosA, posB - adjustedPosA);
        }

        /// <summary>
        /// Get string value after [first] a.
        /// </summary>
        public static string Before(string value, string a)
        {
            int posA = value.IndexOf(a);
            if (posA == -1)
            {
                return "";
            }
            return value.Substring(0, posA);
        }

        /// <summary>
        /// Get string value after [last] a.
        /// </summary>
        public static string After(string value, string a)
        {
            int posA = value.LastIndexOf(a);
            if (posA == -1)
            {
                return "";
            }
            int adjustedPosA = posA + a.Length;
            if (adjustedPosA >= value.Length)
            {
                return "";
            }
            return value.Substring(adjustedPosA);
        }

        private static int Length(object field)
        {
            if (field == null)
                return 0;
            else
                return field.ToString().Trim().Length;
        }

        private static bool NotSameValues(IEnumerable<object> nodes)
        {
            if (nodes == null)
                return false;

            object[] nodesArray = nodes.Cast<object>().ToArray();
            return NotSameValues(nodesArray);
        }

        private static bool NotSameValues(params object[] nodes)
        {
            if (nodes == null)
                return false;

            return ((from x in nodes select x).Distinct().Count() == nodes.Count());
        }

        private static bool HasDuplicateValues(IEnumerable<object> nodes)
        {
            if (nodes == null)
                return false;

            object[] nodesArray = nodes.Cast<object>().ToArray();
            return HasDuplicateValues(nodesArray);
        }

        private static bool HasDuplicateValues(params object[] nodes)
        {
            if (nodes == null)
                return false;

            nodes = nodes.Where(x => x != null).ToArray();
            return !((from x in nodes select x).Distinct().Count() == nodes.Count());

        }

        private int DuplicateValueIndex(IEnumerable<object> values)
        {
            int response = 0;
            var hashset = new HashSet<object>();
            foreach (var value in values)
            {
                if (!hashset.Add(value))
                {
                    return response;
                }
                response++;
            }
            return response;
        }

        private int DuplicateValueIndex<T>(IEnumerable<T?> values) where T : struct
        {
            int response = 0;
            var hashset = new HashSet<T?>();
            foreach (var value in values)
            {
                if (!hashset.Add(value))
                {
                    return response;
                }
                response++;
            }
            return response;
        }

        private static bool IsDate(object value)
        {
            DateTime dateValue;
            return (value != null && DateTime.TryParse(value.ToString(), out dateValue));
        }

        public DateTime AsDate(string dateAsString)
        {
            DateTime response = DateTime.MinValue;
            DateTime date;

            if (DateTime.TryParse(dateAsString, out date))
            {
                response = date;
            }

            return response;
        }
        //The logic in After function expects "---" for day and "--" for month. 
        //Since hyphen was missing the date always returned null
        public DateTime? ConvertToDate(int day, int month, int year)
        {
            return ConvertToDate(day == 0 ? null : "---" + day.ToString(), month == 0 ? null : "--" + month.ToString(), year == 0 ? null : year.ToString());
        }

        public DateTime? ConvertToDate(string day, string month, string year)
        {
            DateTime? response;
            DateTime result;

            if (year == null || month == null || day == null)
            {
                return null;
            }
            string dateAsString = year + "-" + After(month, "--") + "-" + After(day, "---");
            if (DateTime.TryParse(dateAsString, out result))
            {
                response = result;
            }
            else
            {
                response = null;
            }
            return response;
        }


        public DateTime? ConvertToDate(string day, string month, int year)
        {
            DateTime? response;
            DateTime result;

            if (year == 0 || month == null || day == null)
            {
                return null;
            }
            string dateAsString = year.ToString() + "-" + After(month, "--") + "-" + After(day, "---");
            if (DateTime.TryParse(dateAsString, out result))
            {
                response = result;
            }
            else
            {
                response = null;
            }
            return response;
        }


        private static int Day(string dateAsString)
        {
            int response = 0;
            DateTime date;

            if (DateTime.TryParse(dateAsString, out date))
            {
                response = date.Day;
            }

            return response;
        }


        private static int Day(DateTime? date)
        {
            if (date == null)
                return 0;
            else
                return date.Value.Day;

        }


        private static string Month(string dateAsString)
        {
            string response = null;
            DateTime date;

            if (DateTime.TryParse(dateAsString, out date))
            {
                response = date.ToString("MMMM");
            }
            else
            {
                return "NotAMonth";
            }

            return response;
        }

        private static string Month(DateTime? date)
        {
            if (date == null)
                return "NotAMonth";
            else
                return date.Value.ToString("MMMM");
        }


        private static int MonthAsInt(string dateAsString)
        {
            int response = 0;
            DateTime date;

            if (DateTime.TryParse(dateAsString, out date))
            {
                response = date.Month;
            }

            return response;
        }

        private static int MonthAsInt(DateTime? date)
        {
            if (date == null)
            {
                return 0;
            }
            return date.Value.Month;
        }


        private static int Year(string dateAsString)
        {
            int response = 0;
            DateTime date;

            if (DateTime.TryParse(dateAsString, out date))
            {
                response = date.Year;
            }

            return response;
        }

        private static int Year(DateTime? date)
        {
            if (date == null)
                return 0;
            else
                return date.Value.Year;
        }


        private static int CurrentFinancialYear()
        {
            return DateToFinancialYear(DateTime.Now, 7);
        }

        private static int FinancialYear(string dateAsString)
        {
            return DateToFinancialYear(dateAsString, 7);
        }

        private static int FinancialYear(DateTime? date)
        {
            return DateToFinancialYear(date, 7);
        }

        private static int DateToFinancialYear(string dateAsString, int startingMonth)
        {
            int response = 0;
            DateTime date;
            if (DateTime.TryParse(dateAsString, out date))
            {
                response = DateToFinancialYear(date, startingMonth);
            }

            return response;
        }
        private static int DateToFinancialYear(DateTime? date, int startingMonth)
        {
            int response;
            if (date == null)
            {
                response = 0;
            }
            else
            {
                int year = date.Value.Year;
                int month = date.Value.Month;

                if (startingMonth > month)
                    response = year;
                else
                    response = year + 1;
            }
            return response;
        }


        private static int FBTYear(string dateAsString)
        {
            int response = 0;
            DateTime date;

            if (DateTime.TryParse(dateAsString, out date))
                response = FBTYear(date);
            return response;
        }

        private static int FBTYear(DateTime? date)
        {
            if (date == null)
            {
                return 0;
            }
            else
            {
                if (date.Value.Month > 3)
                    return date.Value.Year + 1;
                else
                    return date.Value.Year;
            }
        }

        private static DateTime? AddMonthsToDate(DateTime? dateTime, int months)
        {
            return dateTime == null ? null : (DateTime?)dateTime.Value.AddMonths(months);
        }

        private static bool IsNumeric(object value)
        {
            decimal numbervalue;
            return (value != null && decimal.TryParse(value.ToString(), out numbervalue));
        }

        private static bool NotMonetary(decimal? field, string sign, int digits, int decimals)
        {
            if (field == null)
            {
                return false;
            }
            else
            {
                string signExpression;
                string decimalExpression;
                int digitsToUse = digits - decimals;

                if (sign == "U")
                    signExpression = "^";
                else
                    signExpression = "^-?";

                if (decimals > 0)
                    decimalExpression = @"(\.\d{1," + decimals + "})?$";
                else
                    decimalExpression = @"$";

                return !(Regex.IsMatch(field.Value.ToString("0.#########################"), signExpression + @"\d{1," + digitsToUse + "}" + decimalExpression));
            }
        }

        private static bool NotNumeric(decimal? field, string sign, int digits, int decimals)
        {
            if (field == null)
            {
                return false;
            }
            else
            {
                string signExpression;
                string decimalExpression;
                int digitsToUse = digits - decimals;

                if (sign == "U")
                    signExpression = "^";
                else
                    signExpression = "^-?";

                if (decimals > 0)
                    decimalExpression = @"(\.\d{1," + decimals + "})?$";
                else
                    decimalExpression = @"$";

                return !(Regex.IsMatch(field.Value.ToString("0.#########################"), signExpression + @"\d{1," + digitsToUse + "}" + decimalExpression));
            }
        }

        private static bool NotNumeric(int? field, string sign, int digits, int decimals = 0)
        {
            if (field == null)
            {
                return false;
            }
            else
            {
                string signExpression;

                if (sign == "U")
                    signExpression = "^";
                else
                    signExpression = "^-?";

                return !(Regex.IsMatch(field.Value.ToString(), signExpression + @"\d{1," + digits + "}$"));
            }
        }

        private static bool NotNumeric(long? field, string sign, int digits, int decimals = 0)
        {
            if (field == null)
            {
                return false;
            }
            else
            {
                string signExpression;

                if (sign == "U")
                    signExpression = "^";
                else
                    signExpression = "^-?";

                return !(Regex.IsMatch(field.Value.ToString(), signExpression + @"\d{1," + digits + "}$"));
            }
        }


        private static bool OutsideRange(decimal field, decimal expression, int range)
        {
            bool response;

            response = (field < (expression - range)) || (field > (expression + range));

            return response;
        }


        private static bool FailsUSIAlgorithm(string usi, string abn)
        {
            bool response;
            if (usi == null || abn == null)
            {
                response = false;
            }
            else
            {
                usi = usi.Trim();
                abn = abn.Trim();
                if (usi.Length < 13 || abn.Length < 11)
                {
                    response = false;
                }
                else
                {
                    int numeric;
                    if (usi.Substring(0, 11) == abn && int.TryParse(usi.Substring(11, 2), out numeric))
                        response = false;
                    else if (Regex.IsMatch(usi, @"^[a-zA-Z]{3}\d{4}[a-zA-Z]{2}"))
                        response = false;
                    else
                        response = true;
                }
            }
            return response;
        }


        private static bool FailsTANAlgorithm(string tan)
        {
            bool response;
            decimal decimalTan;

            if (tan == null)
                return false;

            tan = tan.Trim();

            if (!decimal.TryParse(tan, out decimalTan))
                return true;

            if (tan.Length != 8)
                return true;

            decimal tanSum =
                7 * int.Parse(tan.Substring(0, 1)) +
                9 * int.Parse(tan.Substring(1, 1)) +
                8 * int.Parse(tan.Substring(2, 1)) +
                4 * int.Parse(tan.Substring(3, 1)) +
                6 * int.Parse(tan.Substring(4, 1)) +
                3 * int.Parse(tan.Substring(5, 1)) +
                5 * int.Parse(tan.Substring(6, 1)) +
                1 * int.Parse(tan.Substring(7, 1));

            if ((tanSum % 11) == 0)
                response = false;
            else
                response = true;

            return response;
        }


        private static bool FailsABNAlgorithm(string abn)
        {
            bool response;
            decimal decimalAbn;

            if (abn == null)
                return false;

            abn = abn.Trim();

            if (!decimal.TryParse(abn, out decimalAbn))
                return true;

            if (abn.Length != 11)
                return true;

            decimal abnSum =
                10 * (int.Parse(abn.Substring(0, 1)) - 1) +
                1 * int.Parse(abn.Substring(1, 1)) +
                3 * int.Parse(abn.Substring(2, 1)) +
                5 * int.Parse(abn.Substring(3, 1)) +
                7 * int.Parse(abn.Substring(4, 1)) +
                9 * int.Parse(abn.Substring(5, 1)) +
                11 * int.Parse(abn.Substring(6, 1)) +
                13 * int.Parse(abn.Substring(7, 1)) +
                15 * int.Parse(abn.Substring(8, 1)) +
                17 * int.Parse(abn.Substring(9, 1)) +
                19 * int.Parse(abn.Substring(10, 1));

            if ((abnSum % 89) == 0)
                response = false;
            else
                response = true;

            return response;
        }
        private static bool FailsACNAlgorithm(string acn)
        {
            bool response;
            decimal decimalAbn;
            if (acn == null)
                return false;

            acn = acn.Trim();

            if (!decimal.TryParse(acn, out decimalAbn))
                return true;

            if (acn.Length != 9)
                return true;

            decimal abnSum =
                8 * int.Parse(acn.Substring(0, 1)) +
                7 * int.Parse(acn.Substring(1, 1)) +
                6 * int.Parse(acn.Substring(2, 1)) +
                5 * int.Parse(acn.Substring(3, 1)) +
                4 * int.Parse(acn.Substring(4, 1)) +
                3 * int.Parse(acn.Substring(5, 1)) +
                2 * int.Parse(acn.Substring(6, 1)) +
                1 * int.Parse(acn.Substring(7, 1));

            decimal checkDigit = int.Parse(acn.Substring(8, 1));
            decimal acnRemainder = abnSum % 10;

            if (((10 - acnRemainder) % 10) == checkDigit)
                response = false;
            else
                response = true;

            return response;
        }


        private static bool FailsTFNAlgorithm(string tfn)
        {
            bool response;
            decimal decimalTfn;

            if (tfn == null)
                return false;

            tfn = tfn.Trim();
            tfn = Regex.Replace(tfn, "^0+", "");

            if (!decimal.TryParse(tfn, out decimalTfn))
                return true;

            if (tfn.Length < 8)
                return true;


            decimal tfn1To7Sum =
                1 * int.Parse(tfn.Substring(0, 1)) +
                4 * int.Parse(tfn.Substring(1, 1)) +
                3 * int.Parse(tfn.Substring(2, 1)) +
                7 * int.Parse(tfn.Substring(3, 1)) +
                5 * int.Parse(tfn.Substring(4, 1)) +
                8 * int.Parse(tfn.Substring(5, 1)) +
                6 * int.Parse(tfn.Substring(6, 1));

            decimal tfn8 = 9 * int.Parse(tfn.Substring(7, 1));

            if (tfn.Length == 8)
            {
                decimal tFNLg8WSum9 = 10 * int.Parse(tfn.Substring(7, 1));
                decimal tFNLg8WSum = tfn1To7Sum + tFNLg8WSum9;

                if ((tFNLg8WSum % 11) == 0)
                    response = false;
                else
                    response = true;
            }
            else if (tfn.Length == 9)
            {
                decimal tfn9 = 10 * int.Parse(tfn.Substring(8, 1));
                decimal tFNLg9WSum = tfn1To7Sum + tfn8 + tfn9;

                if ((tFNLg9WSum % 11) == 0)
                    response = false;
                else
                    response = true;
            }
            else
            {
                response = true;
            }

            return response;
        }


        private static decimal ConditionalValue(bool expression, decimal? trueVal, decimal? falseVal)
        {
            return expression ? trueVal.GetValueOrDefault() : falseVal.GetValueOrDefault();
        }

        private static decimal AsNumeric(string value)
        {
            decimal numberValue;
            decimal.TryParse(value, out numberValue);
            return numberValue;
        }

        private static bool RegexMatch(int? field, string expression, string flags = "")
        {
            return IsMatch(field, expression, GetRegexOption(flags));
        }

        private static bool RegexMatch(string field, string expression, string flags = "")
        {
            return IsMatch(field, expression, GetRegexOption(flags));
        }

        private static RegexOptions GetRegexOption(string flags)
        {
            RegexOptions options = RegexOptions.None;

            char[] characters = flags.ToCharArray();

            foreach (char character in characters)
            {
                switch (character)
                {
                    case 'i':
                        options = options | RegexOptions.IgnoreCase;
                        break;
                    case 'm':
                        options = options | RegexOptions.Multiline;
                        break;
                    case 's':
                        options = options | RegexOptions.Singleline;
                        break;
                    case 'n':
                        options = options | RegexOptions.ExplicitCapture;
                        break;
                    case 'x':
                        options = options | RegexOptions.IgnorePatternWhitespace;
                        break;
                }
            }

            return options;
        }

        /// <summary>
        /// Returns an occurrence index as [occurrenceIndex] of occurrenceIndex > 0, otherwise the empty string
        /// </summary>
        /// <param name="occurrenceIndex">Index of the occurrence.</param>
        /// <returns>Occurrence in XPath [#] format</returns>
        public string OccurrenceIndex(int occurrenceIndex)
        {
            return occurrenceIndex > 0 ? "[" + occurrenceIndex + "]" : "";
        }

        #endregion // Functions

        public PAYEVNT2018 ConsumedReport { get; private set; }
        public PAYEVNTEMP2018 ConsumedChildReport { get; private set; }

        private static Dictionary<string, ProcessMessageDocument> _processMessageDocuments = new Dictionary<string, ProcessMessageDocument>();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public List<ProcessMessageDocument> ValidateReport(PAYEVNT2018 report, DateTime? CreatedAt = null)
        {

            List<ProcessMessageDocument> response = new List<ProcessMessageDocument>();
            ProcessMessageDocument processMessage;
            ProcessMessageParameter parameter;
            bool assertion;

            this.ConsumedReport = report;

            // ------------------------------------------------------------------------------
            // Validations are now done in code.
            // This version supports full validation of a report - for those rules that have successfully parsed and could be generated.
            // Generated Validations include:
            //   - Validation logic in C#.
            //   - Production of errors in EBMS, SBR and SWS format.
            // 
            // The generation at this stage does not support the following - and has to be completed manually (later versions of the generation will do this for you)
            //   - Business Rules that did not parse.  The ESR team will help support you where this happens as an effort is being made to rectify these
            //   - You will get TODO tasks for those that the parser could not cope with
            // ------------------------------------------------------------------------------


            #region VR.ATO.PAYEVNT.000015

            /*  VR.ATO.PAYEVNT.000015
            The Australian Business Number (ABN) has failed the ABN algorithm check.
    
            Legacy Rule Format:
            FailsABNAlgorithm(^PAYEVNT2)

            Technical Business Rule Format:
            FailsABNAlgorithm(^PAYEVNT2)
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT2 = pyid.02.00:Identifiers.AustralianBusinessNumber.Identifier
            */
            assertion = FailsABNAlgorithm(report.PAYEVNT2);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.GEN.434223",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"ABN is invalid.",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:AustralianBusinessNumberId",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000015" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT2", Value = report.PAYEVNT2 });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000015

            #region VR.ATO.PAYEVNT.000110

            /*  VR.ATO.PAYEVNT.000110
            If provided, must be a valid format.
    
            Legacy Rule Format:
            (^PAYEVNT15 <> NULLORBLANK AND NOT IsValidEmail(^PAYEVNT15))

            Technical Business Rule Format:
            (^PAYEVNT15 <> BLANK AND NOT IsValidEmail(^PAYEVNT15))
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT15 = pyde.02.00:ElectronicContact.ElectronicMail.Address.Text
            */
            assertion = (string.IsNullOrWhiteSpace(report.PAYEVNT15) != true && !(IsMatch(report.PAYEVNT15, @"^\S.*@.+\.\S+$")));
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.GEN.500029",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"Email Address contains invalid text",
                    LongDescription = @"A text character must be one of the following: A to Z a to z 0 to 9 ! @ $ % & * ( ) - _ = [ ] ; : ' "" , . ? / or a space character.",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:ElectronicContact/tns:ElectronicMailAddressT",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000110" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT15", Value = report.PAYEVNT15 });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000110

            #region VR.ATO.PAYEVNT.000170

            /*  VR.ATO.PAYEVNT.000170
            The Payer Declaration Date cannot be later than today.
    
            Legacy Rule Format:
            ^PAYEVNT38 > Today()

            Technical Business Rule Format:
            ^PAYEVNT38 > Today()
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT38 = pyin.02.29:Declaration.Signature.Date
            */
            assertion = (report.PAYEVNT38.GetValueOrDefault() > DateTime.Now.Date);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.PAYEVNT.000193",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"The date entered for Payer Declaration Date must not be later than today's date",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:Declaration/tns:SignatureD",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000170" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT38", Value = GetValueOrEmpty(report.PAYEVNT38) });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000170

            #region VR.ATO.PAYEVNT.000171

            /*  VR.ATO.PAYEVNT.000171
            When the address is overseas, the State / Territory must be null.
    
            Legacy Rule Format:
            ((^PAYEVNT14 <> NULL AND ^PAYEVNT14 <> "au") AND (^PAYEVNT11 <> NULL))

            Technical Business Rule Format:
            ((^PAYEVNT14 <> NULL AND ^PAYEVNT14 <> 'au') AND (^PAYEVNT11 <> NULL))
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT11 = pyde.02.00:AddressDetails.StateOrTerritory.Code
    
            PAYEVNT:^PAYEVNT14 = pyde.02.08:AddressDetails.Country.Code
            */
            assertion = (report.PAYEVNT14 != null && report.PAYEVNT14 != @"au" && report.PAYEVNT11 != null);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.GEN.500011",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"State and postcode must not be present for non-Australian addresses",
                    LongDescription = @"Country name is present with State or postcode in the address field.  Determine whether the address is Australian or overseas and correct accordingly.",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:AddressDetailsPostal/tns:StateOrTerritoryC",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000171" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT14", Value = report.PAYEVNT14 });

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT11", Value = report.PAYEVNT11 });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000171

            #region VR.ATO.PAYEVNT.000172

            /*  VR.ATO.PAYEVNT.000172
            The Australian Business Number (ABN) has failed the ABN algorithm check.
    
            Legacy Rule Format:
            FailsABNAlgorithm(^PAYEVNT64)

            Technical Business Rule Format:
            FailsABNAlgorithm(^PAYEVNT64)
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT64 = pyid.02.00:Identifiers.AustralianBusinessNumber.Identifier
            */
            assertion = FailsABNAlgorithm(report.PAYEVNT64);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.PAYEVNT.000206",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"Intermediary ABN is invalid",
                    Location = "/tns:PAYEVNT/tns:Int/tns:AustralianBusinessNumberId",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000172" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT64", Value = report.PAYEVNT64 });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000172

            #region VR.ATO.PAYEVNT.000173

            /*  VR.ATO.PAYEVNT.000173
            If provided, must be a valid format.
    
            Legacy Rule Format:
            (^PAYEVNT66 <> NULLORBLANK AND NOT IsValidEmail(^PAYEVNT66))

            Technical Business Rule Format:
            (^PAYEVNT66 <> BLANK AND NOT IsValidEmail(^PAYEVNT66))
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT66 = pyde.02.00:ElectronicContact.ElectronicMail.Address.Text
            */
            assertion = (string.IsNullOrWhiteSpace(report.PAYEVNT66) != true && !(IsMatch(report.PAYEVNT66, @"^\S.*@.+\.\S+$")));
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.GEN.500029",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"Email Address contains invalid text",
                    LongDescription = @"A text character must be one of the following: A to Z a to z 0 to 9 ! @ $ % & * ( ) - _ = [ ] ; : ' "" , . ? / or a space character.",
                    Location = "/tns:PAYEVNT/tns:Int/tns:ElectronicContact/tns:ElectronicMailAddressT",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000173" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT66", Value = report.PAYEVNT66 });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000173

            #region VR.ATO.PAYEVNT.000177

            /*  VR.ATO.PAYEVNT.000177
            Either the Payer Australian Business Number or the Payer Withholding Payer Number must be provided.
    
            Legacy Rule Format:
            (^PAYEVNT2 = NULL AND ^PAYEVNT3 = NULL)

            Technical Business Rule Format:
            ^PAYEVNT2 = NULL AND ^PAYEVNT3 = NULL
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT2 = pyid.02.00:Identifiers.AustralianBusinessNumber.Identifier
    
            PAYEVNT:^PAYEVNT3 = pyid.02.00:Identifiers.WithholdingPayerNumber.Identifier
            */
            assertion = (report.PAYEVNT2 == null && report.PAYEVNT3 == null);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.GEN.200010",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"Either ABN or WPN must be present",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:AustralianBusinessNumberId",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000177" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT2", Value = report.PAYEVNT2 });

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT3", Value = report.PAYEVNT3 });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000177

            #region VR.ATO.PAYEVNT.000178

            /*  VR.ATO.PAYEVNT.000178
            When the address is within Australia or set to blank, the State / Territory must be provided.
    
            Legacy Rule Format:
            ((^PAYEVNT14 = NULL OR ^PAYEVNT14 = "au") AND (^PAYEVNT11 = NULL))

            Technical Business Rule Format:
            ((^PAYEVNT14 = NULL OR ^PAYEVNT14 = 'au') AND (^PAYEVNT11 = NULL))
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT11 = pyde.02.00:AddressDetails.StateOrTerritory.Code
    
            PAYEVNT:^PAYEVNT14 = pyde.02.08:AddressDetails.Country.Code
            */
            assertion = ((report.PAYEVNT14 == null || report.PAYEVNT14 == @"au") && report.PAYEVNT11 == null);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.PAYEVNT.000178",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"State/Territory must be provided",
                    LongDescription = @"When the address is within Australia or set to blank, the State / Territory must be provided",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:AddressDetailsPostal/tns:StateOrTerritoryC",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000178" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT14", Value = report.PAYEVNT14 });

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT11", Value = report.PAYEVNT11 });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000178

            #region VR.ATO.PAYEVNT.000179

            /*  VR.ATO.PAYEVNT.000179
            The Postcode must be in the range of '0200-9999'.
    
            Legacy Rule Format:
            (^PAYEVNT12 <> NULL  AND (AsNumeric(^PAYEVNT12) < 200 OR AsNumeric(^PAYEVNT12) > 9999))

            Technical Business Rule Format:
            (^PAYEVNT12 <> NULL  AND (AsNumeric(^PAYEVNT12) < 200 OR AsNumeric(^PAYEVNT12) > 9999))
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT12 = pyde.02.00:AddressDetails.Postcode.Text
            */
            assertion = (report.PAYEVNT12 != null && (AsNumeric(report.PAYEVNT12) < 200 || AsNumeric(report.PAYEVNT12) > 9999));
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.PAYEVNT.000179",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"A valid postcode must be provided",
                    LongDescription = @"The Postcode must be in the range of '0200-9999'",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:AddressDetailsPostal/tns:PostcodeT",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000179" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT12", Value = report.PAYEVNT12 });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000179

            #region VR.ATO.PAYEVNT.000180

            /*  VR.ATO.PAYEVNT.000180
            When the address is overseas, the Postcode must be null.
    
            Legacy Rule Format:
            ((^PAYEVNT14 <> NULL AND ^PAYEVNT14 <> "au") AND (^PAYEVNT12 <> NULL))

            Technical Business Rule Format:
            ((^PAYEVNT14 <> NULL AND ^PAYEVNT14 <> 'au') AND (^PAYEVNT12 <> NULL))
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT12 = pyde.02.00:AddressDetails.Postcode.Text
    
            PAYEVNT:^PAYEVNT14 = pyde.02.08:AddressDetails.Country.Code
            */
            assertion = (report.PAYEVNT14 != null && report.PAYEVNT14 != @"au" && report.PAYEVNT12 != null);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.GEN.000480",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"Country code must be blank or set to Australia",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:AddressDetailsPostal/tns:PostcodeT",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000180" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT14", Value = report.PAYEVNT14 });

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT12", Value = report.PAYEVNT12 });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000180

            #region VR.ATO.PAYEVNT.000183

            /*  VR.ATO.PAYEVNT.000183
            The Payer Withholding Payer Number(WPN) has failed the WPN algorithm check.
    
            Legacy Rule Format:
            FailsWPNAlgorithm(^PAYEVNT3)

            Technical Business Rule Format:
            FailsWPNAlgorithm(^PAYEVNT3)
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT3 = pyid.02.00:Identifiers.WithholdingPayerNumber.Identifier
            */
            assertion = FailsTFNAlgorithm(report.PAYEVNT3);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.GEN.200012",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"Invalid WPN",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:WithholdingPayerNumberId",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000183" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT3", Value = report.PAYEVNT3 });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000183

            #region VR.ATO.PAYEVNT.000184

            /*  VR.ATO.PAYEVNT.000184
            When address is within Australia, the Postcode must be supplied.
    
            Legacy Rule Format:
            ((^PAYEVNT14  = "au" OR ^PAYEVNT14 = NULL) AND ^PAYEVNT12 = NULL)

            Technical Business Rule Format:
            ((^PAYEVNT14 = 'au' OR ^PAYEVNT14 = NULL) AND ^PAYEVNT12 = NULL)
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT12 = pyde.02.00:AddressDetails.Postcode.Text
    
            PAYEVNT:^PAYEVNT14 = pyde.02.08:AddressDetails.Country.Code
            */
            assertion = ((report.PAYEVNT14 == @"au" || report.PAYEVNT14 == null) && report.PAYEVNT12 == null);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.GEN.000009",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"Postcode is required for an Australian address",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:AddressDetailsPostal/tns:PostcodeT",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000184" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT14", Value = report.PAYEVNT14 });

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT12", Value = report.PAYEVNT12 });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000184

            #region VR.ATO.PAYEVNT.000185

            /*  VR.ATO.PAYEVNT.000185
            Payer Declaration Acceptance Indicator must be 'TRUE'.
    
            Legacy Rule Format:
            (^PAYEVNT39 <> TRUE)

            Technical Business Rule Format:
            ^PAYEVNT39 <> TRUE
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT39 = pyin.02.28:Declaration.StatementAccepted.Indicator
            */
            assertion = (report.PAYEVNT39 != true);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.PAYEVNT.000194",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"Payer Declaration Acceptance Indicator must be 'TRUE'",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:Declaration/tns:StatementAcceptedI",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000185" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT39", Value = GetValueOrEmpty(report.PAYEVNT39) });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000185

            #region VR.ATO.PAYEVNT.000203

            /*  VR.ATO.PAYEVNT.000203
            The Registered Agent Number has failed the TAN algorithm check.
    
            Legacy Rule Format:
            (^PAYEVNT65 <> NULL AND FailsTANAlgorithm(^PAYEVNT65))

            Technical Business Rule Format:
            (^PAYEVNT65 <> NULL AND FailsTANAlgorithm(^PAYEVNT65))
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT65 = pyid.02.00:Identifiers.TaxAgentNumber.Identifier
            */
            assertion = (report.PAYEVNT65 != null && FailsTANAlgorithm(report.PAYEVNT65));
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.PAYEVNT.000196",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"Registered Agent Number is invalid",
                    Location = "/tns:PAYEVNT/tns:Int/tns:TaxAgentNumberId",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000203" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT65", Value = report.PAYEVNT65 });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000203

            #region VR.ATO.PAYEVNT.000199

            /*  VR.ATO.PAYEVNT.000199
            Payer Period Totals must be provided.
    
            Legacy Rule Format:
            Count(^PAYEVNT79) = 0

            Technical Business Rule Format:
            Count(^PAYEVNT79) = 0
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT79 = :IncomeTaxAndRemuneration
            */
            assertion = (Count(report.Rp_Payroll_IncomeTaxAndRemunerationCollectionCount) == 0);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.PAYEVNT.000203",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"The Payer Period Totals tuple must be provided",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:Payroll/tns:IncomeTaxAndRemuneration",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000199" } },
                };

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000199

            #region VR.ATO.PAYEVNT.000201

            /*  VR.ATO.PAYEVNT.000201
            The Intermediary Declaration Date cannot be later than today.
    
            Legacy Rule Format:
            ^PAYEVNT42 > Today()

            Technical Business Rule Format:
            ^PAYEVNT42 > Today()
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT42 = pyin.02.29:Declaration.Signature.Date
            */
            assertion = (report.PAYEVNT42.GetValueOrDefault() > DateTime.Now.Date);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.PAYEVNT.000207",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"The date entered for Intermediary Declaration Date must not be later than today's date",
                    Location = "/tns:PAYEVNT/tns:Int/tns:Declaration/tns:SignatureD",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000201" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT42", Value = GetValueOrEmpty(report.PAYEVNT42) });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000201

            #region VR.ATO.PAYEVNT.000202

            /*  VR.ATO.PAYEVNT.000202
            Intermediary Declaration Acceptance Indicator must be 'TRUE'.
    
            Legacy Rule Format:
            (Count(^PAYEVNT81) > 0 AND (^PAYEVNT43 <> TRUE))

            Technical Business Rule Format:
            (Count(^PAYEVNT81) > 0 AND (^PAYEVNT43 <> TRUE))
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT43 = pyin.02.28:Declaration.StatementAccepted.Indicator
    
            PAYEVNT:^PAYEVNT81 = :Int
            */
            assertion = (Count(report.IntCollectionCount) > 0 && report.PAYEVNT43 != true);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.PAYEVNT.000208",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"Intermediary Declaration Acceptance Indicator must be 'TRUE'",
                    Location = "/tns:PAYEVNT/tns:Int/tns:Declaration/tns:StatementAcceptedI",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000202" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT43", Value = GetValueOrEmpty(report.PAYEVNT43) });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000202

            #region VR.ATO.PAYEVNT.000194

            /*  VR.ATO.PAYEVNT.000194
            The Run Date/Time Stamp cannot be later than the time message received in the channel.
    
            Legacy Rule Format:
            (^PAYEVNT71 > AddHoursToDateTime(^Sent_TS timestamp in the Business Document object, 1))

            Technical Business Rule Format:
            (^PAYEVNT71 > AddHoursToDateTime(^Sent_TS timestamp in the Business Document object, 1))
    
            Data Elements:
    
            PAYEVNT:^PAYEVNT71 = pyin.02.00:Message.Timestamp.Generation.Datetime
    
            PAYEVNT:^Sent_TS = Sent_TS
            */
            assertion = (report.PAYEVNT71.Value.AddHours(-1).ToUniversalTime() > CreatedAt);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.PAYEVNT.000200",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"The Run Date/Time Stamp cannot be later than the time message received in the channel",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:Payroll/tns:MessageTimestampGenerationDt",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000194" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "PAYEVNT71", Value = (report.PAYEVNT71.HasValue) ? report.PAYEVNT71.Value.ToUniversalTime().ToString("u") : string.Empty });

                processMessage.Parameters.Add(new ProcessMessageParameter
                { Name = "Sent_TS", Value = CreatedAt.Value.ToString("u") });

                response.Add(processMessage);
            }
            #endregion // VR.ATO.PAYEVNT.000194

            foreach (ProcessMessageDocument currentProcessMessage in response)
            {
                if (currentProcessMessage.Parameters != null)
                {
                    foreach (ProcessMessageParameter currentParameter in currentProcessMessage.Parameters)
                    {
                        if (string.IsNullOrEmpty(currentParameter.Name))
                        {
                            currentParameter.Name = _emptyParameterValue;
                        }

                        if (currentParameter.Name.Length > _maxParameterNameLength)
                        {
                            currentParameter.Name = currentParameter.Name.Substring(0, _maxParameterNameLength - 1);
                        }

                        if (string.IsNullOrEmpty(currentParameter.Value))
                        {
                            currentParameter.Value = _emptyParameterValue;
                        }

                        if (currentParameter.Value.Length > _maxParameterValueLength)
                        {
                            currentParameter.Value = currentParameter.Value.Substring(0, _maxParameterValueLength - 1);
                        }
                    }
                }
            }

            return response;
        }
        public List<ProcessMessageDocument> ValidateCrossformReport(PAYEVNT2018 report, PAYEVNTEMP2018 childReport, int childcount = 0)
        {
            List<ProcessMessageDocument> response = new List<ProcessMessageDocument>();
            ProcessMessageDocument processMessage;
            ProcessMessageParameter parameter;
            bool assertion;

            this.ConsumedChildReport = childReport;

            #region VR.ATO.PAYEVNT.000192

            /*  VR.ATO.PAYEVNT.000192 - Documented in ATO PAYEVNT.0003 2018 Valdiation Rules
            At least one PAYEVNTEMP child must be provided
    
            Legacy Rule Format:
            Count(^PAYEVNTEMP) = 0

            Technical Business Rule Format:
            Count(^PAYEVNTEMP) = 0
            */

            assertion = (childcount == 0);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.PAYEVNT.000192",
                    Severity = ProcessMessageSeverity.Error,
                    Description = @"At least one PAYEVNTEMP child must be provided",
                    Location = null,
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000192" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter { Name = "PAYEVNTEMP", Value = "PAYEVNTEMP" });

                response.Add(processMessage);
            }
            #endregion VR.ATO.PAYEVNT.000192

            #region VR.ATO.PAYEVNT.000191

            /*  VR.ATO.PAYEVNT.000191 - Documented in ATO PAYEVNT.0003 2018 Valdiation Rules
            Payee Record Count must be equal to the number of children (PAYEVNTEMP)
    
            Legacy Rule Format:
            (^PAYEVNT70 <> Count(^PAYEVNTEMP))

            Technical Business Rule Format:
            (^PAYEVNT70 <> Count(^PAYEVNTEMP))
            */
            assertion = (report.PAYEVNT70.GetValueOrDefault() != childcount);
            if (assertion)
            {
                processMessage = new ProcessMessageDocument()
                {
                    Code = "CMN.ATO.PAYEVNT.000191",
                    Severity = ProcessMessageSeverity.Warning,
                    Description = @"Payee Record Count must be equal to the number of children (PAYEVNTEMP)",
                    Location = "/tns:PAYEVNT/tns:Rp/tns:Payroll/tns:InteractionRecordCt",
                    Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNT.000191" } },
                };

                processMessage.Parameters.Add(new ProcessMessageParameter { Name = "PAYEVNT70", Value = report.PAYEVNT70.ToString() });

                response.Add(processMessage);
            }
            #endregion

            #region VR.ATO.PAYEVNTEMP.000180

            /*  VR.ATO.PAYEVNTEMP.000180 - Documented in ATO PAYEVNTEMP.0003 2018 Valdiation Rules
            Both ETP Payment Date as well as Pay/Update Date must be in the same financial year.
    
            Technical Business Rule Format:
            (FinancialYear(^PAYEVNTEMP123) <> FinancialYear(^PAYEVNT69))
            */

            assertion = false;

            if (childReport != null)
            {
                if (childReport.Payee_RemunerationIncomeTaxPayAsYouGoWithholding_EmploymentTerminationPaymentCollection != null)
                {
                    PAYEVNTEMP2018.Payee_RemunerationIncomeTaxPayAsYouGoWithholding_EmploymentTerminationPayment employmentTerminationPayment = childReport.Payee_RemunerationIncomeTaxPayAsYouGoWithholding_EmploymentTerminationPaymentCollection.Find(f => DateToFinancialYear(report.PAYEVNT69, 7) != DateToFinancialYear(f.PAYEVNTEMP123.Value, 7));

                    if (employmentTerminationPayment != null)
                        assertion = true;

                    if (assertion)
                    {
                        processMessage = new ProcessMessageDocument()
                        {
                            Code = "CMN.ATO.PAYEVNTEMP.000180",
                            Severity = ProcessMessageSeverity.Error,
                            Description = @"ETP payment date must be in the same financial year as the Pay/Update Date",
                            Location = "/tns:PAYEVNTEMP/tns:Payee/tns:RemunerationIncomeTaxPayAsYouGoWithholding/tns:EmploymentTerminationPaymentCollection/tns:EmploymentTerminationPayment/tns:PaymentRecordPaymentEffectiveD",
                            Parameters = new ProcessMessageParameters() { new ProcessMessageParameter() { Name = "RuleIdentifier", Value = "VR.ATO.PAYEVNTEMP.000180" } },
                        };

                        processMessage.Parameters.Add(new ProcessMessageParameter { Name = "PAYEVNTEMP123", Value = employmentTerminationPayment.PAYEVNTEMP123.ToString() });

                        response.Add(processMessage);
                    }
                }
            }
            #endregion

            foreach (ProcessMessageDocument currentProcessMessage in response)
            {
                if (currentProcessMessage.Parameters != null)
                {
                    foreach (ProcessMessageParameter currentParameter in currentProcessMessage.Parameters)
                    {
                        if (string.IsNullOrEmpty(currentParameter.Name))
                        {
                            currentParameter.Name = _emptyParameterValue;
                        }

                        if (currentParameter.Name.Length > _maxParameterNameLength)
                        {
                            currentParameter.Name = currentParameter.Name.Substring(0, _maxParameterNameLength - 1);
                        }

                        if (string.IsNullOrEmpty(currentParameter.Value))
                        {
                            currentParameter.Value = _emptyParameterValue;
                        }

                        if (currentParameter.Value.Length > _maxParameterValueLength)
                        {
                            currentParameter.Value = currentParameter.Value.Substring(0, _maxParameterValueLength - 1);
                        }
                    }
                }
            }

            return response;
        }

    }
}
